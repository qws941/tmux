#!/usr/bin/env bash
# tmux-sidebar — persistent session list panel (display-only)
# Runs in a narrow left pane, auto-refreshes every 1s
# Tokyo Night color scheme
#
# Sort: attached sessions first, then unattached (alphabetical within each)
# Highlight: ▸ = current (blue bg), ● = attached (green), dim = inactive

set -uo pipefail

# Tokyo Night ANSI colors
readonly C_RESET='\033[0m'
readonly C_BG='\033[48;2;26;27;38m'       # #1a1b26
readonly C_FG='\033[38;2;169;177;214m'     # #a9b1d6
readonly C_ACCENT='\033[38;2;122;162;247m' # #7aa2f7
readonly C_ACTIVE='\033[1;38;2;122;162;247m' # #7aa2f7 bold
readonly C_ACTIVE_BG='\033[48;2;41;46;66m'   # #292e42 bg highlight
readonly C_DIM='\033[38;2;86;95;137m'      # #565f89
readonly C_IDLE='\033[38;2;52;58;80m'     # #343a50 — very dim for idle
readonly C_GREEN='\033[38;2;158;206;106m'  # #9ece6a
readonly C_PURPLE='\033[38;2;187;154;247m' # #bb9af7
readonly C_BORDER='\033[38;2;59;66;97m'    # #3b4261
readonly C_CYAN='\033[38;2;125;207;255m'   # #7dcfff
readonly C_YELLOW='\033[38;2;224;175;104m'  # #e0af68

# OC status — detect opencode + parse TUI for tokens/cost/agent
get_oc_status() {
    local session="$1" width="$2"

    # Find the opencode pane in this session
    local pane_info oc_pane=""
    while IFS=' ' read -r pane_id pane_cmd; do
        if [[ "$pane_cmd" == "opencode" ]]; then
            oc_pane="$pane_id"
            break
        fi
    done < <(tmux list-panes -t "$session" -F '#{pane_id} #{pane_current_command}' 2>/dev/null)
    [[ -z "$oc_pane" ]] && return 1

    # Capture TUI and parse status line (contains tokens, %, cost)
    local tui_output
    tui_output=$(tmux capture-pane -t "$oc_pane" -p 2>/dev/null)

    # Parse header line: "# Title                       154,748  77% ($0.00)"
    local tokens="" pct="" cost=""
    local header_line
    header_line=$(echo "$tui_output" | grep -P '^\s+┃\s+#' | head -1)
    if [[ -n "$header_line" ]]; then
        tokens=$(echo "$header_line" | grep -oP '[\d,]+(?=\s+\d+%)' | tr -d ',')
        pct=$(echo "$header_line" | grep -oP '\d+(?=%)')
        cost=$(echo "$header_line" | grep -oP '\$[\d.]+')
    fi

    # Parse agent line: "▣  Sisyphus · claude-opus-4.6"
    local agent=""
    local agent_line
    agent_line=$(echo "$tui_output" | grep '▣' | tail -1)
    if [[ -n "$agent_line" ]]; then
        agent=$(echo "$agent_line" | sed 's/.*▣[[:space:]]*//' | awk '{print $1}')
    fi

    # Detect environment from process environ
    local env_name="oc"
    local shell_pid
    shell_pid=$(tmux list-panes -t "$session" -F '#{pane_id} #{pane_pid}' 2>/dev/null | grep "$oc_pane" | awk '{print $2}')
    if [[ -n "$shell_pid" ]]; then
        local oc_pid
        oc_pid=$(pgrep -P "$shell_pid" -x opencode 2>/dev/null | head -1)
        if [[ -n "$oc_pid" && -r "/proc/$oc_pid/environ" ]]; then
            local port
            port=$(tr '\0' '\n' < "/proc/$oc_pid/environ" 2>/dev/null | grep '^OPENCODE_SERVER_URL=' | grep -oP ':\K\d+' | tail -1)
            case "$port" in
                3011) env_name="anti" ;;
                3012) env_name="claude" ;;
                3013) env_name="co" ;;
            esac
        fi
    fi

    # Format token count (compact: 154748 → 154k)
    local tok_fmt=""
    if [[ -n "$tokens" ]]; then
        if [[ "$tokens" -ge 1000 ]]; then
            tok_fmt="$((tokens / 1000))k"
        else
            tok_fmt="$tokens"
        fi
    fi

    # Output structured lines for the footer renderer
    # Line 1: env + agent
    # Line 2: tokens + pct + cost
    if [[ $width -le 15 ]]; then
        echo "${env_name}"
        [[ -n "$tok_fmt" ]] && echo "${tok_fmt} ${pct}%"
    else
        local line1="${env_name}"
        [[ -n "$agent" && "$agent" != "" ]] && line1="${env_name} · ${agent}"
        echo "$line1"
        if [[ -n "$tok_fmt" ]]; then
            local line2="${tok_fmt} tok · ${pct}%"
            [[ -n "$cost" ]] && line2="${line2} · ${cost}"
            echo "$line2"
        fi
    fi
    return 0
}

# Mosh detection — walk process tree for mosh-server ancestor
is_mosh() {
    pstree -s $$ 2>/dev/null | grep -q mosh
}

# Refresh interval: aggressive locally, gentle over mosh
if is_mosh; then
    REFRESH_INTERVAL=2
else
    REFRESH_INTERVAL=0.5
fi

# Get terminal dimensions
get_height() { tput lines 2>/dev/null || echo 24; }
get_width() { tput cols 2>/dev/null || echo 20; }

# Hide cursor, restore on exit
setup_terminal() {
    tput civis 2>/dev/null  # hide cursor
    tput smcup 2>/dev/null  # alternate screen
    trap cleanup EXIT INT TERM
}

cleanup() {
    tput cnorm 2>/dev/null  # show cursor
    tput rmcup 2>/dev/null  # restore screen
    exit 0
}

# Draw a horizontal line
draw_line() {
    local width=$1
    local char="${2:-─}"
    local line=""
    for ((i = 0; i < width; i++)); do
        line+="$char"
    done
    echo -ne "${C_BORDER}${line}${C_RESET}"
}

# Truncate string to width
truncate() {
    local str="$1"
    local max="$2"
    if [[ ${#str} -gt $max ]]; then
        echo "${str:0:$((max - 1))}…"
    else
        echo "$str"
    fi
}

# Render a single session line
render_session() {
    local name="$1" windows="$2" attached="$3"
    local width="$4" inner="$5" is_current="$6" is_narrow="$7"
    local idx="$8"

    local indicator=" "
    local color="$C_DIM"
    local bg=""

    if [[ "$is_current" == "1" ]]; then
        indicator="▸"
        color="$C_ACTIVE"
        bg="$C_ACTIVE_BG"
    elif [[ "$attached" -gt 0 ]]; then
        indicator="●"
        color="$C_GREEN"
    fi

    local display_name
    local num_prefix="${C_DIM}${idx}${C_RESET}"
    if [[ "$is_narrow" == "1" ]]; then
        display_name=$(truncate "$name" $((inner - 4)))
        printf " ${bg}${num_prefix}${color}%s%s${C_RESET}" "$indicator" "$display_name"
        tput el 2>/dev/null
        echo ""
    else
        display_name=$(truncate "$name" $((inner - 5)))
        local badge=""
        if [[ "$windows" -gt 1 ]]; then
            badge="${C_DIM}[${windows}]${C_RESET}"
        fi
        printf " ${bg}${num_prefix}${color}%s%-*s${C_RESET} %b" \
            "$indicator" $((inner - 7)) "$display_name" "$badge"
        tput el 2>/dev/null
        echo ""
    fi
}

# Render the sidebar
render() {
    local width height inner is_narrow current_session
    width=$(get_width)
    height=$(get_height)
    inner=$((width - 2))
    is_narrow=0
    [[ $width -le 15 ]] && is_narrow=1

    current_session=$(tmux display-message -p '#{session_name}' 2>/dev/null || echo "")

    # Move to top-left
    tput cup 0 0

    # Header
    if [[ $is_narrow == 1 ]]; then
        printf " ${C_ACCENT}%-*s${C_RESET}\n" "$inner" "Sess"
    else
        printf " ${C_ACCENT}%-*s${C_RESET}\n" "$inner" "Sessions"
    fi
    echo -ne " "
    draw_line "$inner"
    echo ""

    # Flat list: sorted by most recently active
    local line_num=3
    local max_lines=$((height - 6))  # Reserve room for OC status + footer
    local idx=1

    while IFS='|' read -r name windows attached path activity; do
        [[ $line_num -ge $max_lines ]] && break
        local is_cur=0
        [[ "$name" == "$current_session" ]] && is_cur=1
        render_session "$name" "$windows" "$attached" "$width" "$inner" "$is_cur" "$is_narrow" "$idx"
        line_num=$((line_num + 1))
        idx=$((idx + 1))
    done < <(tmux list-sessions -F '#{session_name}|#{session_windows}|#{session_attached}|#{session_path}|#{session_activity}' 2>/dev/null | sort -t'|' -k5,5 -rn)

    # Clear remaining lines
    while [[ $line_num -lt $((height - 2)) ]]; do
        tput cup "$line_num" 0
        tput el 2>/dev/null
        ((line_num++))
    done

    # OC status + Footer
    local oc_lines=()
    local oc_raw
    oc_raw=$(get_oc_status "$current_session" "$width")
    if [[ -n "$oc_raw" ]]; then
        while IFS= read -r l; do
            oc_lines+=("$l")
        done <<< "$oc_raw"
    fi

    local footer_lines=$(( 1 + ${#oc_lines[@]} + (${#oc_lines[@]} > 0 ? 1 : 0) ))
    local footer_start=$((height - footer_lines))

    # Clear lines between session list and footer
    while [[ $line_num -lt $footer_start ]]; do
        tput cup "$line_num" 0
        tput el 2>/dev/null
        ((line_num++))
    done

    if [[ ${#oc_lines[@]} -gt 0 ]]; then
        tput cup "$footer_start" 0
        echo -ne " "
        draw_line "$inner"
        echo ""

        # Line 1: env · agent
        printf " ${C_CYAN}▸ ${C_YELLOW}%s${C_RESET}" "${oc_lines[0]}"
        tput el 2>/dev/null
        echo ""

        # Line 2: tokens · pct · cost (if present)
        if [[ ${#oc_lines[@]} -gt 1 ]]; then
            printf " ${C_DIM}%s${C_RESET}" "${oc_lines[1]}"
            tput el 2>/dev/null
        fi
    fi

    tput cup $((height - 1)) 0
    tput el 2>/dev/null
}

# Main loop — smart redraw: skip if nothing changed
main() {
    setup_terminal
    local last_hash=""

    while true; do
        local state oc_state
        state=$(tmux list-sessions -F '#{session_name}:#{session_attached}:#{session_windows}:#{session_activity}' 2>/dev/null)
        oc_state=$(tmux display-message -p '#{session_name}' 2>/dev/null)
        oc_state="${oc_state}:$(pgrep -x opencode 2>/dev/null | head -1)"
        local cur_hash
        cur_hash=$(echo "${state}${oc_state}" | md5sum | cut -c1-16)

        if [[ "$cur_hash" != "$last_hash" ]]; then
            render
            last_hash="$cur_hash"
        fi

        sleep "$REFRESH_INTERVAL"
    done
}

main "$@"

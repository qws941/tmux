#!/usr/bin/env bash
# tmux-sidebar — persistent session list panel (display-only)
# Runs in a narrow left pane, auto-refreshes every 1s
# Tokyo Night color scheme
#
# Sort: attached sessions first, then unattached (alphabetical within each)
# Highlight: > = current (blue bg stripe), * = attached (green), dim = inactive

set -euo pipefail

# Tokyo Night ANSI colors
readonly C_RESET='\033[0m'
readonly C_BG='\033[48;2;26;27;38m'       # #1a1b26 night bg
readonly C_FG='\033[38;2;169;177;214m'     # #a9b1d6
readonly C_ACCENT='\033[38;2;61;89;161m'   # #3d59a1 accent
readonly C_ACTIVE='\033[1;38;2;192;202;245m' # #c0caf5 bright fg (bold)
readonly C_ACTIVE_BG='\033[48;2;41;46;66m'   # #292e42 visual bg (visible stripe)
readonly C_DIM='\033[38;2;59;66;97m'       # #3b4261 dim
readonly C_IDLE='\033[38;2;34;36;54m'      # #222436 night idle
readonly C_GREEN='\033[38;2;115;218;202m'  # #73daca teal
readonly C_PURPLE='\033[38;2;157;124;216m' # #9d7cd8 purple
readonly C_BORDER='\033[38;2;34;36;54m'    # #222436 night border
readonly C_CYAN='\033[38;2;125;207;255m'   # #7dcfff
readonly C_YELLOW='\033[38;2;224;175;104m' # #e0af68

# Mosh detection — check env var (fast) or process tree (fallback)
is_mosh() {
    [[ -n "${MOSH_KEY:-}" ]] && return 0
    pstree -s $$ 2>/dev/null | grep -q mosh
}

# Refresh interval: gentle over mosh (save bandwidth), aggressive locally
if is_mosh; then
    REFRESH_INTERVAL=3
else
    REFRESH_INTERVAL=0.5
fi

# Get terminal dimensions
get_height() { tput lines 2>/dev/null || echo 24; }
get_width() { tput cols 2>/dev/null || echo 20; }

# Hide cursor, restore on exit
setup_terminal() {
    tput civis 2>/dev/null  # hide cursor
    tput smcup 2>/dev/null  # alternate screen
    trap cleanup EXIT INT TERM
}

cleanup() {
    tput cnorm 2>/dev/null  # show cursor
    tput rmcup 2>/dev/null  # restore screen
    exit 0
}

# Draw a horizontal line
draw_line() {
    local width=$1
    local char="${2:--}"
    local line=""
    for ((i = 0; i < width; i++)); do
        line+="$char"
    done
    echo -ne "${C_BORDER}${line}${C_RESET}"
}

# Truncate string to display width (CJK-aware)
truncate() {
    local str="$1"
    local max="$2"
    local dw
    dw=$(printf '%s' "$str" | wc -L)
    if [[ $dw -gt $max ]]; then
        # Remove chars from end until display width fits
        local s="$str"
        while [[ $(printf '%s' "$s" | wc -L) -gt $((max - 1)) && -n "$s" ]]; do
            s="${s%?}"
        done
        echo "${s}.."
    else
        echo "$str"
    fi
}

# Render a single session line
render_session() {
    local name="$1" windows="$2" attached="$3"
    local width="$4" inner="$5" is_current="$6" is_narrow="$7"
    local idx="$8"

    local indicator=" "
    local color="$C_DIM"
    local bg=""

    if [[ "$is_current" == "1" ]]; then
        indicator=">"
        color="$C_ACTIVE"
        bg="$C_ACTIVE_BG"
    elif [[ "$attached" -gt 0 ]]; then
        indicator="*"
        color="$C_GREEN"
    fi

    local display_name
    if [[ "$is_narrow" == "1" ]]; then
        display_name=$(truncate "$name" $((inner - 4)))
        local content=" ${idx}${indicator}${display_name}"
        local pad=$((width - ${#content}))
        [[ $pad -lt 0 ]] && pad=0
        if [[ -n "$bg" ]]; then
            printf " ${bg}${C_DIM}${idx}${C_RESET}${bg}${color}%s%s%*s${C_RESET}\n" "$indicator" "$display_name" "$pad" ""
        else
            printf " ${C_DIM}${idx}${C_RESET}${color}%s%s${C_RESET}" "$indicator" "$display_name"
            tput el 2>/dev/null
            echo ""
        fi
    else
        display_name=$(truncate "$name" $((inner - 5)))
        local badge_text=""
        local badge=""
        if [[ "$windows" -gt 1 ]]; then
            badge_text="[${windows}]"
            badge="${C_DIM}${badge_text}${C_RESET}"
        fi
        if [[ -n "$bg" ]]; then
            local content=" ${idx}${indicator}${display_name} ${badge_text}"
            local pad=$((width - ${#content}))
            [[ $pad -lt 0 ]] && pad=0
            printf " ${bg}${C_DIM}${idx}${C_RESET}${bg}${color}%s%-*s${C_RESET}${bg} %b%*s${C_RESET}\n" \
                "$indicator" $((inner - 7)) "$display_name" "$badge" "$pad" ""
        else
            printf " ${C_DIM}${idx}${C_RESET}${color}%s%-*s${C_RESET} %b" \
                "$indicator" $((inner - 7)) "$display_name" "$badge"
            tput el 2>/dev/null
            echo ""
        fi
    fi
}

# Render the sidebar
render() {
    local width height inner is_narrow current_session
    width=$(get_width)
    height=$(get_height)
    inner=$((width - 2))
    is_narrow=0
    [[ $width -le 15 ]] && is_narrow=1

    current_session=$(tmux display-message -p '#{session_name}' 2>/dev/null || echo "")

    # Move to top-left
    tput cup 0 0

    # Header
    if [[ $is_narrow == 1 ]]; then
        printf " ${C_ACCENT}%-*s${C_RESET}\n" "$inner" "Sess"
    else
        printf " ${C_ACCENT}%-*s${C_RESET}\n" "$inner" "Sessions"
    fi
    echo -ne " "
    draw_line "$inner"
    echo ""

    # Flat list: sorted by most recently active
    local line_num=3
    local max_lines=$((height - 2))
    local idx=1

    while IFS='|' read -r name windows attached path activity; do
        [[ $line_num -ge $max_lines ]] && break
        local is_cur=0
        [[ "$name" == "$current_session" ]] && is_cur=1
        render_session "$name" "$windows" "$attached" "$width" "$inner" "$is_cur" "$is_narrow" "$idx"
        line_num=$((line_num + 1))
        idx=$((idx + 1))
    done < <(tmux list-sessions -F '#{session_name}|#{session_windows}|#{session_attached}|#{session_path}|#{session_activity}' 2>/dev/null)

    # Clear remaining lines
    while [[ $line_num -lt $((height - 1)) ]]; do
        tput cup "$line_num" 0
        tput el 2>/dev/null
        ((line_num++))
    done
}

# Main loop — smart redraw: skip if nothing changed
main() {
    setup_terminal
    local last_hash=""

    while true; do
        local state
        # Removed session_activity — changes on every keystroke, causes
        # constant rerenders and wastes bandwidth over mosh
        state=$(tmux list-sessions -F '#{session_name}:#{session_attached}:#{session_windows}' 2>/dev/null)

        local cur_hash
        cur_hash=$(echo "$state" | md5sum | cut -c1-16)

        if [[ "$cur_hash" != "$last_hash" ]]; then
            render
            last_hash="$cur_hash"
        fi

        sleep "$REFRESH_INTERVAL"
    done
}

main "$@"
